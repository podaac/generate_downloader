#!/bin/csh
#
#  Copyright 2017, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM
#
#
# This is the C-shell wrapper to download the VIIRS/MODIS Level 2/ Level 3, and Aquarius NetCDF files from OBPG due to the "Recent" interface disappearing.
#
# It will usually be ran as part of a crontab.  Note that this script makes many requests to OBPG and they have
# a limit to 30 requests per minute per machine.  The variable sleep_time_in_between_files may have to be adjusted if there are errors from the Python script. 
#
# The log files created will be in directory $HOME/logs with the extension .log
#
# The list_directory parameter is the directory of download lists created by the create_generic_download_list.py script.
#
################################################################################################################################################################

# Set the environments.

# source $HOME/define_modis_operation_environment_for_combiner
source /app/config/downloader_config    # NET edit. (Docker container)

# Get the input.

if ($# < 9) then
echo $#
    echo "startup_generic_downloader:ERROR, You must specify at least 9 arguments: list_directory processing_level separator_character processing_type top_level_output_directory num_files_to_download sleep_time_in_between_files maximum_number_of_processes move_filelist_file_when_done"
    echo "startup_generic_downloader:Usage:"
    echo ""
    echo "    source startup_generic_downloader.csh ~/scratch/viirs_level2_download_list    L2 SPACE VIIRS    /data/dev/scratch/qchau/IO/data 1    0 1 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level2_download_list    L2 SPACE MODIS_A  /data/dev/scratch/qchau/IO/data 1    0 1 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level2_download_list    L2 SPACE MODIS_T  /data/dev/scratch/qchau/IO/data 1    0 1 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level3_download_list    L3 SPACE MODIS_A  /data/dev/scratch/qchau/IO/data 1    0 1 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level3_download_list    L3 SPACE MODIS_T  /data/dev/scratch/qchau/IO/data 1    0 1 no  no"
    echo ""
    echo "    source startup_generic_downloader.csh ~/scratch/viirs_level2_download_list    L2 SPACE VIIRS    /data/dev/scratch/qchau/IO/data 5    0 4 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level2_download_list    L2 SPACE MODIS_A  /data/dev/scratch/qchau/IO/data 5    0 4 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level2_download_list    L2 SPACE MODIS_T  /data/dev/scratch/qchau/IO/data 5    0 4 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level3_download_list    L3 SPACE MODIS_T  /data/dev/scratch/qchau/IO/data 5    0 4 no  no"
    echo "    source startup_generic_downloader.csh ~/scratch/modis_level3_download_list    L3 SPACE MODIS_T  /data/dev/scratch/qchau/IO/data 5    0 4 no  no"
    exit
endif

# The parameters for startup_generic_downloader.csh are:
#
#  1 = list_directory 
#  2 = processing_level
#  3 = separator_character
#  4 = processing_type
#  5 = top_level_output_directory
#  6 = num_files_to_download
#  7 = sleep_time_in_between_files
#  8 = maximum_number_of_processes
#  9 = move_filelist_file_when_done
# 10 = perform_checksum_flag
# 11 = test_run_flag 

set list_directory              = $1
set processing_level            = $2
set separator_character         = $3
set processing_type             = $4
set top_level_output_directory  = $5
set num_files_to_download       = $6
set sleep_time_in_between_files = $7
set maximum_number_of_processes = $8
set move_filelist_file_when_done = $9
set perform_checksum_flag        = $10
set test_run_flag                = $11

if ($maximum_number_of_processes == "") then
    set maximum_number_of_processes = 20
endif

# Create the logs directory if it does not exist yet   # NET edit.
set logging_dir = `printenv | grep OBPG_DOWNLOADER_LOGGING | awk -F= '{print $2}'`
if (! -e $logging_dir) then    # NET edit.
    mkdir $logging_dir    # NET edit.
endif

# set log_top_level_directory = "$HOME/logs"
set log_top_level_directory = $logging_dir    # NET edit.

# Get today's date so we can name our log file.
# The format will be mm_dd_yy_HH_MM as in 09_19_12_16_02
# The touch command is to create an empty file if it does not exist yet.

# Note: This date is to be Pacific Time.
setenv TZ PST8PDT
set today_date = `date '+%m_%d_%y_%H_%M'`

# For each name found in the given particular directory, we run the Perl script as a separate background process sending out to unique log file.

set names_to_look_for = "";

if ($processing_type == "VIIRS") then
     set names_to_look_for = "viirs_filelist.txt*";
endif 

if ($processing_type == "MODIS_A") then
     set names_to_look_for = "modis_aqua_filelist.txt*";
endif 
if ($processing_type == "MODIS_T") then
     set names_to_look_for = "modis_terra_filelist.txt*";
endif 
if ($processing_type == "AQUARIUS") then
     set names_to_look_for = "aquarius_filelist.txt*";
endif 

set list_processed = 1
echo "COMMAND:  ls -lctr $list_directory/$names_to_look_for"

##########################################################################################################################
# Because the quicklook has new priority, we must process any list that contains a quicklook first and the refined second.
##########################################################################################################################

# Set the clock to GMT
# Note:
#   1.  This date is to be Greenwich Mean Time.
#   2.  The year format code is 'Y' to signify a 4 digit year.

setenv TZ GMT

# Grab test date if executing test run    # NET edit. (Testing)
set test_run = `printenv | grep TEST_RUN | awk -F= '{print $2}'`
if ($test_run == "true") then
   set the_year = `printenv | grep THE_YEAR | awk -F= '{print $2}'`
   set the_month = `printenv | grep THE_MONTH | awk -F= '{print $2}'`
   set the_day = `printenv | grep THE_DAY | awk -F= '{print $2}'`
   set yesterday_year = `printenv | grep YESTERDAY_YEAR | awk -F= '{print $2}'`
   set yesterday_month = `printenv | grep YESTERDAY_MONTH | awk -F= '{print $2}'`
   set yesterday_day = `printenv | grep YESTERDAY_DAY | awk -F= '{print $2}'`
else
   # Otherwise use today's date
   set the_year  = `date '+%Y'`
   set the_month = `date '+%m'`
   set the_day   = `date '+%d'`
   # Get yesterday's date in case we are a few hours late.
   set yesterday_year  = `date --date="yesterday" '+%Y'`
   set yesterday_month = `date --date="yesterday" '+%m'`
   set yesterday_day   = `date --date="yesterday" '+%d'`
endif

# Don't forget to to set the time zone back to local.

setenv TZ PST8PDT

#DEBUG:echo "the_year  $the_year"
#DEBUG:echo "the_month $the_month"
#DEBUG:echo "the_day   $the_day"
#DEBUG:echo "yesterday_year  $yesterday_year"
#DEBUG:echo "yesterday_month $yesterday_month"
#DEBUG:echo "yesterday_day   $yesterday_day"

set quicklook_temporary_list_filename = "$log_top_level_directory/${the_year}_${the_month}_${the_day}_${processing_level}_${processing_type}_quicklook_temporary_download_list.txt"
if (-e $quicklook_temporary_list_filename) then
   echo "Removing existing file $quicklook_temporary_list_filename"
   rm -f $quicklook_temporary_list_filename
endif 

touch $quicklook_temporary_list_filename

set refined_temporary_list_filename = "$log_top_level_directory/${the_year}_${the_month}_${the_day}_${processing_level}_${processing_type}_refined_temporary_download_list.txt"
if (-e $refined_temporary_list_filename) then
   echo "Removing existing file $refined_temporary_list_filename"
   rm -f $refined_temporary_list_filename
endif

touch $refined_temporary_list_filename

set num_names_added_to_temporary_list = 0


# For every name found, check to see if it contains the quicklook.  If it does, save it in $quicklook_temporary_list_filename
# otherwise, save it in $refined_temporary_list_filename.
# After all the names are created, combine the two together with the quickook first.

set python_exe = `printenv | grep PYTHON3_EXECUTABLE_PATH | awk -F= '{print $2}'`    # NET edit.
foreach file_list_to_download (`ls -r $list_directory/$names_to_look_for`)
    # Some dataset does not have the concept of quicklook or refined.
    # We set them to refined by default.
    set found_quicklook_flag = 0
#    echo "processing_type $processing_type"
    if (processing_type != "AQUARIUS") then
        set found_quicklook_flag = `$python_exe $OBPG_RUNENV_PYTHON_HOME/does_list_contain_quicklook_granules.py $file_list_to_download $separator_character $the_year $the_month $the_day $yesterday_year $yesterday_month $yesterday_day | grep FOUND_QUICKLOOK_FLAG | awk '{print $2}'`    # NET edit (python3 not python.)
#DEBUG:    echo "file_list_to_download $file_list_to_download found_quicklook_flag $found_quicklook_flag"
    endif
    if ($found_quicklook_flag == 1) then 
#        echo "Saving $file_list_to_download to file $quicklook_temporary_list_filename"
        echo $file_list_to_download >> $quicklook_temporary_list_filename
    else
#        echo "Saving $file_list_to_download to file $refined_temporary_list_filename"
        echo $file_list_to_download >> $refined_temporary_list_filename
    endif
    @ num_names_added_to_temporary_list = $num_names_added_to_temporary_list + 1; 

#    echo "num_names_added_to_temporary_list $num_names_added_to_temporary_list"
#    exit
end


#DEBUG:echo "wc -l $quicklook_temporary_list_filename"
#DEBUG:wc -l $quicklook_temporary_list_filename
#DEBUG:echo "wc -l $refined_temporary_list_filename"
#DEBUG:wc -l $refined_temporary_list_filename

#echo "cat -n $refined_temporary_list_filename"
#exit

# Now combine the quicklook and combined together but place the quicklook first using the cat command.

set total_temporary_list_filename = "$log_top_level_directory/${the_year}_${the_month}_${the_day}_${processing_level}_${processing_type}_total_temporary_download_list.txt"
if (-e $total_temporary_list_filename) then
   echo "Removing existing file $total_temporary_list_filename"
   rm -f $total_temporary_list_filename
endif

# Combine the quicklook and refined names together into one file.

touch $total_temporary_list_filename
cat $quicklook_temporary_list_filename $refined_temporary_list_filename >> $total_temporary_list_filename

#DEBUG:echo "wc -l $total_temporary_list_filename"
#DEBUG:wc -l $total_temporary_list_filename

# Delete the temporary files

rm -f $quicklook_temporary_list_filename
rm -f $refined_temporary_list_filename

# Note: We must list the file based on oldest last modified time first since we want to process the files
#       first come first serve and not based on the file name.
#       The command is ls -ctr
#       6/5/2013: The order of the list is now based on quicklook first, refined last via the command "cat $total_temporary_list_filename".

#OLD:foreach file_list_to_download (`ls -ctr $list_directory/$names_to_look_for`)

# Set this flag DOWNLOADER_UNIT_TEST so the python script get_unique_python_processes_on_system.py will run correctly.
setenv DOWNLOADER_UNIT_TEST false

foreach file_list_to_download (`cat $total_temporary_list_filename`)

    # Do a sanity check to make sure we don't start up a Perl process when there are already too many.
    set scratch = `printenv | grep SCRATCH_AREA | awk -F= '{print $2}'`    # NET edit.
    # If running VIIRS, only check for VIIRS processes.
    if $processing_type == 'VIIRS' then
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level VIIRS"
        set num_processes_currently_running = `$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level VIIRS`
        setenv JOB_DIRECTORY $scratch/viirs_level2_download_processes    # NET edit.
        if ($processing_level == "L2") then 
            set name_snippet = "viirs_level2"
        endif
    endif
    # If running MODIS_A, only check for MODIS_A processes.
    if $processing_type == 'MODIS_A' then
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level MODIS_A"
        # echo "python $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level MODIS_A"    # NET edit.
        set num_processes_currently_running = `$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level MODIS_A`
        set name_snippet = "modis_aqua"
        echo "$num_processes_currently_running"
        if ($processing_level == "L2") then 
            set name_snippet = "modis_level2_aqua"
            setenv JOB_DIRECTORY $scratch/modis_aqua_level2_download_processes    # NET edit.
        endif
        if ($processing_level == "L3") then 
            set name_snippet = "modis_level3_aqua"
            setenv JOB_DIRECTORY $scratch/modis_aqua_level3_download_processes    # NET edit.
        endif
    endif
    # If running MODIS_T, only check for MODIS_T processes.
    if $processing_type == 'MODIS_T' then
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level MODIS_T"
        set num_processes_currently_running = `$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level MODIS_T`
        set name_snippet = "modis_terra"
        if ($processing_level == "L2") then
            set name_snippet = "modis_level2_terra"
            setenv JOB_DIRECTORY $scratch/modis_terra_level2_download_processes    # NET edit.
        endif
        if ($processing_level == "L3") then
            set name_snippet = "modis_level3_terra"
            setenv JOB_DIRECTORY $scratch/modis_terra_level3_download_processes    # NET edit.
        endif
    endif
    # If running AQUARIUS, only check for AQUARIUS processes.
    if $processing_type == 'AQUARIUS' then
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level AQUARIUS"
        set num_processes_currently_running = `$python_exe $OBPG_RUNENV_PYTHON_HOME/get_unique_python_processes_on_system.py generic_level2_downloader $processing_level AQUARIUS`
        echo 'set num_processes_currently_running = `ps -ef | grep generic_level2_downloader | grep AQUARIUS | grep python | grep -v grep | wc -l`'
        setenv JOB_DIRECTORY $scratch/aquarius_download_processes    # NET edit.
        set name_snippet = "aquarius"
        if ($processing_level == "L2") then
            set name_snippet = "aquarius_level2"
        endif
        if ($processing_level == "L3") then
            set name_snippet = "aquarius_level3"
        endif
    endif

    echo "num_processes_currently_running [$num_processes_currently_running]"


    if ($num_processes_currently_running>= $maximum_number_of_processes) then
        echo "num_processes_currently_running $num_processes_currently_running is equal or more than maximum_number_of_processes $maximum_number_of_processes"
        echo "Maximum number of processes $num_processes_currently_running are already running on this machine.  Nothing to do for this cycle."
        break;
    else
        echo "num_processes_currently_running $num_processes_currently_running is less than maximum_number_of_processes $maximum_number_of_processes"
    endif

    # Add leading zeros to keep the file name's length constant.
    set digits_in_name = "";
    if ($list_processed >= 0 && $list_processed <= 9) then 
        set digits_in_name = "000$list_processed"; # Add 3 leading zeros if between 0 and 9 inclusive.
    endif
    if ($list_processed >= 10 && $list_processed <= 99) then 
        set digits_in_name = "00$list_processed";  # Add 2 leading zeros if between 10 and 99 inclusive.
    endif
    if ($list_processed >= 100 && $list_processed <= 999) then 
        set digits_in_name = "0$list_processed";   # Add 1 leading zero if between 100 and 999 inclusive.
    endif
    if ($list_processed >= 1000                         ) then 
        set digits_in_name = "$list_processed";   # Add no leading zero if greater than or equal 1000.
    endif

    set downloader_log_name = "$log_top_level_directory/$name_snippet""_${processing_type}_downloader_output_${today_date}_list_${digits_in_name}.log"
    set job_name_only             =    "obpg_download_process_$name_snippet""_${processing_type}_downloader_output_${today_date}_list_${digits_in_name}.txt"


    # Create a directory it it does not exist yet.
    # setenv JOB_DIRECTORY $HOME/scratch/viirs_level2_download_processes
    if (! -e $JOB_DIRECTORY) then
        mkdir -p $JOB_DIRECTORY
        chmod 777 $JOB_DIRECTORY    # NET edit. (Allow removal of directory on disk)
    endif

    # Write a file to signify that the a job has been started.
    # This file name should be passed onto the generic_level2_downloader.python script so it can be deleted when the job is done.
    # Another process (more than likely startup_generic_downloader.csh) can interogate the last modified time of this file with some threshold value.
    # If the file is older than the threshold, the job may be hung.

    setenv JOB_NAME_ONLY "obpg_download_process_"$name_snippet"_${processing_type}_downloader_output_${today_date}_list_${digits_in_name}.txt"
    setenv JOB_FULL_NAME $JOB_DIRECTORY/$JOB_NAME_ONLY

    # Create an empty file.

    touch $JOB_FULL_NAME

    #
    # Write a command into the file so the user can run it to check for the process id and other information when they get a sigevent.
    #

    echo "# This file was created by the startup_generic_downloader.csh C-shell script."                                              >> $JOB_FULL_NAME
    echo "# The below command if ran, should show a download process currently on the system."                                        >> $JOB_FULL_NAME
    echo "# The log associated with this process is $downloader_log_name"                                                             >> $JOB_FULL_NAME
    echo ""                                                                                                                           >> $JOB_FULL_NAME
    echo "    ps -ef | grep generic_level2_downloader | grep python | grep -v grep | grep $file_list_to_download | grep $today_date " >> $JOB_FULL_NAME
    echo ""                                                                                                                       >> $JOB_FULL_NAME

    echo "$JOB_DIRECTORY/obpg_download_process_"$name_snippet"_${processing_type}_downloader_output_${today_date}_list_${digits_in_name}.txt"
    
    
    echo "file_list_to_download [$file_list_to_download]"


    rm -f $downloader_log_name
    touch $downloader_log_name
    
    if ($test_run_flag == "true") then
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/generic_level2_downloader.py $file_list_to_download $processing_level $separator_character $processing_type $top_level_output_directory $num_files_to_download $sleep_time_in_between_files $move_filelist_file_when_done $perform_checksum_flag $today_date $JOB_FULL_NAME $test_run_flag "
        $python_exe $OBPG_RUNENV_PYTHON_HOME/generic_level2_downloader.py $file_list_to_download $separator_character $processing_type $top_level_output_directory $num_files_to_download $sleep_time_in_between_files $move_filelist_file_when_done $perform_checksum_flag $today_date  $JOB_FULL_NAME $test_run_flag &
    else
        echo "FILE LIST TO DOWNLOAD    $file_list_to_download"
        echo "$python_exe $OBPG_RUNENV_PYTHON_HOME/generic_level2_downloader.py $file_list_to_download $processing_level $separator_character $processing_type $top_level_output_directory $num_files_to_download $sleep_time_in_between_files $move_filelist_file_when_done $perform_checksum_flag $today_date $JOB_FULL_NAME $test_run_flag >> $downloader_log_name &"
        $python_exe $OBPG_RUNENV_PYTHON_HOME/generic_level2_downloader.py $file_list_to_download $processing_level $separator_character $processing_type $top_level_output_directory $num_files_to_download $sleep_time_in_between_files $move_filelist_file_when_done $perform_checksum_flag $today_date  $JOB_FULL_NAME $test_run_flag >> $downloader_log_name &
    endif
    @ list_processed = $list_processed + 1; 

    # Sleep for a few seconds to give the operating system a chance to start each Perl script.

    sleep 3

    # Break if reached maximum number of lists.
    # Note that we cannot delete the file $total_temporary_list_filename since it is still open.
    # We can delete if outside of the foreach loop.
    if ($list_processed > $maximum_number_of_processes) then
        echo "Reached maximum number of list to process $list_processed."
        break;
    endif
end    # End for each download file list.

# Wait for all child subprocesses to complete before exiting.
wait

if (-e $total_temporary_list_filename) then
    echo "rm -f $total_temporary_list_filename"
    rm -f $total_temporary_list_filename
endif

exit
