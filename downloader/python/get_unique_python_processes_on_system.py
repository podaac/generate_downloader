#  Copyright 2017, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

#------------------------------------------------------------------------------------------------

# This Python program returns the number of unique Python processes currently running on the system performing downloading function.  It is used
# mainly by the downloader C-shell script to determine if it should spawn a new download process or not based on how many are currently running.
#
# This program returns a number and print out a number.  It is up to the C-shell script to parse and interprete the output.
#
# For developer to use from command line:
#
#    python get_unique_python_processes_on_system.py generic_level2_downloader L2 VIIRS
#    python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_A
#    python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_T
#    python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_A
#    python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_T
#    python get_unique_python_processes_on_system.py generic_level2_downloader L2 AQUARIUS
#    python get_unique_python_processes_on_system.py generic_level2_downloader L3 AQUARIUS
#
# If running a unit test, the following can be run first
#
#     setenv DOWNLOADER_UNIT_TEST true
#
# and then run the above 4 calls.

import os
import re
import subprocess
import sys

def get_unique_python_processes_on_system(i_python_module_name,
                                          i_processing_level,
                                          i_processing_type):

    debug_module = "get_unique_python_processes_on_system:";
    debug_mode   = 0;

    global g_debug_messages;
    global g_function_called_from_command_line;
    global g_downloader_unit_test_flag;

    # If running a unit test, set debug_mode to 1 so we can see debug messages.
    if (g_downloader_unit_test_flag):
        debug_mode   = 1;
 
    # We will also ignore the name of this process since it will shows up on the "ps" command as one of the processes running on the system.

    ignore_this_process_name = "get_unique_python_processes_on_system";

    # Create a hash table of unique processes.  This allows us to inspect if a particular process has already been added.
    # At the end, we can get the number of elements in the hash table.  This is our unique Python processes running on the system perform downloading function.

    unique_processes_table = {}; 

    # Make the system call with the "ps" command to get current processes on the system.
    # The output will be returned in an array of strings with carriage returns so the chomp function can be used to remove them.
    #
    # Description of commands:
    #    ps -ef        Shows all active processes
    #    grep -v tail  Ignore any tail command line  (This is when the developer is tailing a certain log file.)
    #    grep -v head  Ignore any head command line
    #    grep -v grep  Ignore the grep process 
    #    grep -v vim   Ignore any editor being run as it is in development
    #    grep i_python_module_name  Looking for process with the name in i_python_module_name  (Hopefully this is the same as the Python script that does the download)
    #    grep i_processing_type   Looking for this stream only, e.g MODIS_A or MODIS_T  (This allows us to give each stream its own quota of processes.)
    #    grep -vE 'python.ignore_this_process_name.pl'  This will ignore this program because it will shows up as "00:00:00 python get_unique_python_processes_on_system.pl" on the process list. 
    

    try:
       pipe_output = subprocess.check_output(['ps','-ef'], universal_newlines=True);
       pipe_output_as_list = pipe_output.split('\n');
    except OSError:
       print("0000");
       print(debug_module + "ERROR: Cannot get the number of unique python process on system for process " + i_python_module_name);
       return;

    line_count = 0;
    o_hash_keys_added = 0;

    # Parse through each output line.  Becareful to remove the carriage return.
    # Assumption: Each line has more than 3 tokens.
   
    for one_line in pipe_output_as_list:
        line_count = line_count + 1;
        one_line   = one_line.strip().rstrip('/');


        if (debug_mode):
            print(debug_module + "one_line",one_line);

        # Now we begin a series of skips to simulate the pipe command with the grep.
        if one_line == "":
            if (debug_mode):
                print(debug_module + "SKIP:EMPTY_LINE");
            continue;
        if ("head " in one_line) or ("tail " in one_line):
            if (debug_mode):
                print(debug_module + "SKIP:GREP_HEAD_OR_TAIL");
            continue;
        if ("grep " in one_line) or ("vim " in one_line):
            if (debug_mode):
                print(debug_module + "SKIP:GREP_VIM_MODULE_TYPE");
            continue;
        if (not "python " in one_line):
            if (debug_mode):
                print(debug_module + "SKIP:NON_PYTHON");
            continue;

        

        # If the developer is running a unit test, the following code will be ignored.
        # That means that at least one process will not be skipped, which will allow the code to
        if (g_downloader_unit_test_flag == False):
            if (ignore_this_process_name in one_line) and (i_processing_type in one_line):
                if (debug_mode):
                    print(debug_module + "SKIP:THIS_FUNCTION_RUNNING:",one_line);
                continue
        else:
            # Set the debug mode so we can see the logic and then reset debug_mode back to 1 if it was at 1 originally.
            reset_mode = 0;
            # If the user wanted to be in debug mode, we set reset_mode 1 so we can reset it back.
            if (debug_mode == 1):
                reset_mode = 1;
            if (ignore_this_process_name in one_line) and ((i_processing_type in one_line) and (i_processing_level in one_line)):
                if (debug_mode):
                    print(debug_module + "KEEP:THIS_FUNCTION_RUNNING:",one_line);
            if (reset_mode == 1):
                debug_mode = 1;

        # This is what we are looking for.
        if (i_python_module_name in one_line) and (i_processing_type in one_line):
            if (debug_mode):
                print(debug_module + "FOUND_THIS:SUBPROCESS_RUNNING",one_line);
        else:
            if (debug_mode):
                print(debug_module + "SKIP:OTHER",one_line);
            continue;

        # qchau    26076 15301  0 17:29 pts/47   00:00:00 python get_unique_python_processes_on_system.pl modis_level2_downloader_historical MODIS_A

        # Split the line by using space(s) so we can get access to the process id, and parent id.

        splitted_tokens = re.split('\s+',one_line);
        if (len(splitted_tokens) > 2):
            process_id = splitted_tokens[1];  # Get the 2nd column which is the process id.
            parent_id  = splitted_tokens[2];  # Get the 3rd column which is this process' parent id.
        else:
            if (debug_mode):
                print(debug_module + "SKIP:NOT_ENOUGH_TOKENS[",one_line,"]");
            continue;

        if not process_id.isdigit():
            if (debug_mode):
                print(debug_module + "SKIP:NOT_DIGIT");
            continue;


        if (debug_mode):
            print(debug_module + "one_line",one_line);
            print(debug_module + "process_id",process_id);
            print(debug_module + "parent_id",parent_id);
            print(debug_module + "splitted_tokens[7]", splitted_tokens[7]);
            print(debug_module + "splitted_tokens[8]", splitted_tokens[8]);
            print(debug_module + "splitted_tokens[9]", splitted_tokens[9]);
            print(debug_module + "splitted_tokens[10]",splitted_tokens[10]);

        # The logic is somewhat tricky.  We check to see if the parent_id is in the hash table.  If the parent_id does not exist in the hash table,
        # we add the process_id.  The reason is when Perl sub processes are forked (created), they share the same parent_id.
        # The ps command will show both the parent and as many child sub processes there are.  As long as this script is concern the child sub processes don't count.
        # Even if the sub process has died, it is still listed in the process table (noted by <defunct> in the last column.
        #
        # The first line is the parent process.
        # The 2nd line on, shares the same parent, so we don't count them. 

        #    qchau    20158 21508  1 13:23 pts/21   00:00:00 python /home/qchau/sandbox/trunk/ghrsst-rdac/combine/src/main/python/modis_level2_downloader_historical.pl /home/qchau/scratch/modis_level2_download_list/modis_aqua_filelist.txt.daily_2015_039 SPACE MODIS_A /data/dev/scratch/qchau/IO/data 27 0 no yes 05_31_16_13_23 /home/qchau/scratch/modis_level2_download_processes/obpg_download_process_modis_level2_MODIS_A_downloader_output_05_31_16_13_23_list_0001.txt false
        #    qchau    20160 20158  0 13:23 pts/21   00:00:00 python /home/qchau/sandbox/trunk/ghrsst-rdac/combine/src/main/python/modis_level2_downloader_historical.pl /home/qchau/scratch/modis_level2_download_list/modis_aqua_filelist.txt.daily_2015_039 SPACE MODIS_A /data/dev/scratch/qchau/IO/data 27 0 no yes 05_31_16_13_23 /home/qchau/scratch/modis_level2_download_processes/obpg_download_process_modis_level2_MODIS_A_downloader_output_05_31_16_13_23_list_0001.txt false
        #    qchau    20161 20158  0 13:23 pts/21   00:00:00 python /home/qchau/sandbox/trunk/ghrsst-rdac/combine/src/main/python/modis_level2_downloader_historical.pl /home/qchau/scratch/modis_level2_download_list/modis_aqua_filelist.txt.daily_2015_039 SPACE MODIS_A /data/dev/scratch/qchau/IO/data 27 0 no yes 05_31_16_13_23 /home/qchau/scratch/modis_level2_download_processes/obpg_download_process_modis_level2_MODIS_A_downloader_output_05_31_16_13_23_list_0001.txt false
        #    qchau    20162 20158  0 13:23 pts/21   00:00:00 python /home/qchau/sandbox/trunk/ghrsst-rdac/combine/src/main/python/modis_level2_downloader_historical.pl /home/qchau/scratch/modis_level2_download_list/modis_aqua_filelist.txt.daily_2015_039 SPACE MODIS_A /data/dev/scratch/qchau/IO/data 27 0 no yes 05_31_16_13_23 /home/qchau/scratch/modis_level2_download_processes/obpg_download_process_modis_level2_MODIS_A_downloader_output_05_31_16_13_23_list_0001.txt false
        #    qchau    20163 20158  0 13:23 pts/21   00:00:00 python /home/qchau/sandbox/trunk/ghrsst-rdac/combine/src/main/python/modis_level2_downloader_historical.pl /home/qchau/scratch/modis_level2_download_list/modis_aqua_filelist.txt.daily_2015_039 SPACE MODIS_A /data/dev/scratch/qchau/IO/data 27 0 no yes 05_31_16_13_23 /home/qchau/scratch/modis_level2_download_processes/obpg_download_process_modis_level2_MODIS_A_downloader_output_05_31_16_13_23_list_0001.txt false
        #
        #    qchau    20160 20158  0 13:23 pts/21   00:00:00 [python] <defunct>
        #    qchau    20173 20158  0 13:23 pts/21   00:00:00 [python] <defunct>
        #    qchau    20205 20199  0 13:23 pts/21   00:00:00 [python] <defunct>
        #    qchau    20206 20199  0 13:23 pts/21   00:00:00 [python] <defunct>

        if (not parent_id in unique_processes_table):
            unique_processes_table[process_id] = process_id;   # Add a value of process_id both as key and as value.
            o_hash_keys_added = o_hash_keys_added + 1;
            if (debug_mode):
                print(debug_module + "PROCESS_ADDED KEY [" + process_id + "] VALUE [" + process_id + "]");

    # If this function was called from command line, we actually print the output so it can be parsed by the callee.
    if (g_function_called_from_command_line == True):
        print('{:04d}'.format(o_hash_keys_added));
    return(o_hash_keys_added);

if __name__ == "__main__":
    # python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_A
    # python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_T
    # python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_A
    # python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_T
    # python get_unique_python_processes_on_system.py generic_level2_downloader L2 VIIRS
    # python get_unique_python_processes_on_system.py generic_level2_downloader L2 AQUARIUS
    # python get_unique_python_processes_on_system.py generic_level2_downloader L3 AQUARIUS 
    routine_name = "get_unique_python_processes_on_system";
    debug_module = "get_unique_python_processes_on_system:";
    debug_mode = 0;

    # Get the input parameters.
    
    if (len(sys.argv) <= 3):
        print(debug_module + "ERROR: This program requires at least 3 parameters:");
        print("    python get_unique_python_processes_on_system.py i_python_module_name i_processing_level i_processing_type");
        print("");
        print("Example:");
        print("");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_A");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L2 MODIS_T");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_A");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L3 MODIS_T");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L2 VIIRS");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L2 AQUARIUS");
        print("    python get_unique_python_processes_on_system.py generic_level2_downloader L3 AQUARIUS");
        print("");
        exit(1);

    i_python_module_name = sys.argv[1];
    i_processing_level   = sys.argv[2];
    i_processing_type    = sys.argv[3]; 

    global g_function_called_from_command_line;
    g_function_called_from_command_line = True;

    # If developer is running a test, this value should be set to true so at least 1 process can be retrieved from the ps command.
    #
    #     setenv DOWNLOADER_UNIT_TEST true
    #
    # The global variable g_downloader_unit_test_flag will set to True and a section of the code will be ignored.

    global g_downloader_unit_test_flag;
    if (os.getenv('DOWNLOADER_UNIT_TEST','') == 'true'):
        g_downloader_unit_test_flag = True;
    else:
        g_downloader_unit_test_flag = False;

    o_hash_keys_added = get_unique_python_processes_on_system(i_python_module_name,i_processing_level,i_processing_type);
    exit(1);
