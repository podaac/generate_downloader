#  Copyright 2017, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Function to handle when a downloader has error.  This function differ slightly to handle_downloader_error() in that it writes to
# a common incomplete file instead of writing to a new file to limit the number of single file list.

import os
import sys

from time import strftime

from delete_error_count import delete_error_count;
from get_local_time import get_local_pdt_time;
from log_this import log_this;
from nfs_lock_file_wrapper import nfs_lock_file_wrapper;
from nfs_unlock_file       import nfs_unlock_file;
from notify                import notify

sigevent_type = "information";
sigevent_msg = "hello there";
sigevent_data = "";

#------------------------------------------------------------------------------------------------------------------------
def handle_downloader_error_historical(i_full_pathname_to_download,
                                       i_filelist_name,
                                       i_checksum_value):

    # Because the downloading frequently encounter issues, we want to make some modifications:
    #
    #   1.  Every time an error has occurred on a particular file, we check to see how many times an error has occurred on
    #       this file.  The error count is on the file system.  We will call this an error count file.
    #   2.  If the error count has not reached 5 times, we raise a WARN sigevent, update the error count by increment the error count by 1.
    #       If the count has reached 5 times, we raise an ERROR sigevent and delete the error count file.
    #

    # Local variables.

    g_routine_name = "handle_downloader_error_historical";
    debug_module = "handle_downloader_error_historical:";
    debug_mode   = 0;

    if (os.getenv('CRAWLER_SEARCH_DEBUG_FLAG','') == 'true'):
        debug_mode = 1;

    # Output variables.

    o_incomplete_filename = "";  # Will return the name of the incompleted file if have not reached the threshold.  If raised an error, this will return empty string.

    ERROR_COUNT_THRESHOLD = 5;

    # If the user has set a different threshold, we reset it.
    # No other handling is done.  Set this value at your own risk.
    if (os.getenv('OBPG_RUNENV_ERROR_COUNT_THRESHOLD','') != ''):
        ERROR_COUNT_THRESHOLD = int(os.getenv('OBPG_RUNENV_ERROR_COUNT_THRESHOLD','')); 
        sigevent_msg = "RESET ERROR_COUNT_THRESHOLD " + str(ERROR_COUNT_THRESHOLD);
        log_this("INFO",g_routine_name,sigevent_msg);
    else:
        sigevent_msg = "ORIGINAL ERROR_COUNT_THRESHOLD " + str(ERROR_COUNT_THRESHOLD);
        log_this("INFO",g_routine_name,sigevent_msg);

    # Get the error count from file system.

    error_count = fetch_error_count(i_full_pathname_to_download);  # If this is the first time, the count will be zero.  
    error_count = error_count + 1;                               # Increment the error by 1 to show that we have encountered an error.

    # If the eror count is less than the threshold, raise a WARN sigevent and update the error count file.
    if (error_count < ERROR_COUNT_THRESHOLD):
        sigevent_msg = "The number of download errors for " + i_full_pathname_to_download + " is " + str(error_count) + ", max is " + str(ERROR_COUNT_THRESHOLD);
        sigevent_type = "WARN";
        sigevent_description = g_routine_name + ":" + sigevent_msg
        notify(sigevent_type, sigevent_description, sigevent_data)
        log_this("WARN",g_routine_name,sigevent_msg);
        update_error_count(i_full_pathname_to_download,error_count);

        # Create an incomplete file name so we can write the name of the file that were weren't able to download.
        # Whether the checksum is good or bad, we go ahead and create the incomplete file so it can be retried again.
        create_incomplete_file_flag = 1;

        if (create_incomplete_file_flag == 1):
            pos_to_dot_text = i_filelist_name.index(".txt");            # /home/qchau/scratch/modis_level2_download_list/modis_terra_filelist.txt.0082
            base_download_name = i_filelist_name[0:pos_to_dot_text+4];  # /home/qchau/scratch/modis_level2_download_list/modis_terra_filelist.txt


            # New logic: Instead of writing the errant file to a file list of 1, we write to the one file for this particular stream.
            o_incomplete_filename = base_download_name + ".common_incomplete_file";

            # Do a sanity check to see if the new o_incomplete_filename is the same as i_filelist_name.
            # If they are the same, we will add the date to the name.
            if (o_incomplete_filename == i_filelist_name):
                localtime = get_local_pdt_time();
                now_string = strftime("%Y_%m_%d_%H_%M_%S",localtime);
                o_incomplete_filename = o_incomplete_filename  + "_" + now_string;
                sigevent_msg = "UPDATED_INCOMPLETE_FILENAME " + o_incomplete_filename;
                log_this("INFO",g_routine_name,sigevent_msg);

            (ok_to_write_file_flag,o_the_lock) = nfs_lock_file_wrapper(o_incomplete_filename,None);
            if (debug_mode):
                print(debug_module + "ok_to_write_file_flag",ok_to_write_file_flag,"o_the_lock",o_the_lock);

            if (ok_to_write_file_flag):
                try:
                    f = open(o_incomplete_filename,'a');
                except IOError:
                    print(debug_module + "ERROR: Cannot open file " + i_filelist_name);
                    o_files_download_status = 0;
                    return(o_files_download_status);
                else:
                    with f:
                        f.write(i_full_pathname_to_download + " " + i_checksum_value + "\n");
                log_this("ERROR",g_routine_name,"INCOMPLETE_DOWNLOAD_FILE_SAVED " + i_full_pathname_to_download + " TO " + o_incomplete_filename);
                o_unlock_status = nfs_unlock_file(o_the_lock,
                                                  o_incomplete_filename);
        # end if (create_incomplete_file_flag == 1)
    else:
        # The error count has reached the threshold, raise an ERROR sigevent and delete the the error count file.
        sigevent_msg = "The number of download errors for " + i_full_pathname_to_download + " has reached " + str(ERROR_COUNT_THRESHOLD);
        sigevent_type = "ERROR";
        sigevent_description = g_routine_name + ":" + sigevent_msg
        notify(sigevent_type, sigevent_description, sigevent_data)
        sigevent_msg = sigevent_msg + "  An ERROR sigevent has been raised.";
        log_this("ERROR",g_routine_name,sigevent_msg);
        delete_error_count(i_full_pathname_to_download);
    #end else if (error_count < ERROR_COUNT_THRESHOLD)

    return(o_incomplete_filename);

#------------------------------------------------------------------------------------------------------------------------
def get_next_filename(i_baseDownloadListFilename):
    # Given a name, we look for an existence of a file with a number after it, start with 1.
    # If that name does not exist, we return it.

    nextNumberInName = 1;
    nextNumberFound  = 0;

    o_nextFilename = "";
    while (nextNumberFound == 0):
        o_nextFilename = "%s.%04d" % (i_baseDownloadListFilename,nextNumberInName);
        nextFile = o_nextFilename;
        if (not os.path.isfile(nextFile)):
            nextNumberFound = 1;
        else:
            nextNumberInName += 1;

    return(o_nextFilename);

#------------------------------------------------------------------------------------------------------------------------
def fetch_error_count(i_full_pathname):

    # Given a full pathname, we look for an existence of a matching file on the file system and read in the error count.
    # If the file does not exist yet, we assume the count is 0.
    #
    # A full path name to download looks like this.
    #
    #     http://oceandata.sci.gsfc.nasa.gov/cgi/getfile/T2013150003500.L2_LAC_SST.bz2
    
    g_routine_name = "fetch_error_count";
    debug_module = "fetch_error_count:";
    debug_mode   = 1;

    o_error_count = 0;

    # Parse the full path name just for the name only.

    last_slash_pos = i_full_pathname.rindex("/");

    name_only = i_full_pathname[last_slash_pos+1:];   # The name_only variable should now be T2013150003500.L2_LAC_SST.bz2 
    error_count_filename = name_only + ".error_count";
    # scratch_count_directory = os.getenv('HOME','') + "/scratch/";
    scratch_count_directory = os.getenv('DOWNLOAD_ERROR_COUNTS_LOCATION','') + "/"    # NET edit.
    if (not os.path.exists(scratch_count_directory)):
        try:
            print(debug_module + "create directory " + scratch_count_directory);
            os.umask(000)
            os.makedirs(scratch_count_directory, 0o777)    # NET edit. (Allow removal of directory on disk)
        except OSError as exception:
            print(debug_module + "WARN: Cannot create directory" + scratch_count_directory);

    error_count_directory = scratch_count_directory + "generic_download_error_counts/";
    if (not os.path.exists(error_count_directory)):
        try:
            print(debug_module + "create directory " + error_count_directory);
            os.umask(000)
            os.makedirs(error_count_directory, 0o777)    # NET edit. (Allow removal of directory on disk)
        except OSError as exception:
            print(debug_module + "WARN: Cannot create directory" + error_count_directory);

    full_error_count_pathname = error_count_directory + error_count_filename;
    if (debug_mode):
        print(debug_module + "full_error_count_pathname ",full_error_count_pathname);

    if (os.path.isfile(full_error_count_pathname)):
        lines = None;
        try:
            f = open(full_error_count_pathname,'r');
        except IOError:
            print(debug_module + "ERROR: Cannot open file for reading " + full_error_count_pathname);
            o_files_download_status = 0;
            return(o_error_count);
        else:
            with f:
                print("  f.readlines");
                lines = f.readlines();

        # It is possible that lines has not been assigned or zero lines read.
        if (lines is not None) and (len(lines) > 0):
            print(debug_module + "type(lines)", type(lines));
            print(debug_module + "lines", lines);
            splitted_array = lines[0].split(' ');
            o_error_count  = int(splitted_array[0]); 
    else:
        log_this("INFO",g_routine_name,"FILE_NEW " + full_error_count_pathname);

    if (debug_mode):
        print(debug_module + "o_error_count [" + str(o_error_count));
    return(o_error_count);

#------------------------------------------------------------------------------------------------------------------------
def update_error_count(i_full_pathname,
                       i_error_count):

    # Given a full pathname and a new error count, we write the new error count to file.
    # If the file does not exist yet, we write a new file.  If the file exist, it will be over written.
    #
    # A full path name to download looks like this.
    #
    #     http://oceandata.sci.gsfc.nasa.gov/cgi/getfile/T2013150003500.L2_LAC_SST.bz2


    g_routine_name = "update_error_count";
    debug_module   = "update_error_count:";
    debug_mode     = 1;

    # Parse the full path name just for the name only.

    last_slash_pos = i_full_pathname.rindex('/');

    name_only = i_full_pathname[last_slash_pos+1:];   # The name_only variable should now be T2013150003500.L2_LAC_SST.bz2 
    error_count_filename = name_only + ".error_count";

    scratch_count_directory = os.getenv('HOME','') + "/scratch/";
    if (not os.path.exists(scratch_count_directory)):
        try:
            print(debug_module + "create directory " + scratch_count_directory);
            os.umask(000)
            os.makedirs(scratch_count_directory, 0o777)    # NET edit. (Allow removal of directory on disk)
        except OSError as exception:
            print(debug_module + "WARN: Cannot create directory" + scratch_count_directory);

    error_count_directory = scratch_count_directory + "generic_download_error_counts/";
    if (not os.path.exists(error_count_directory)):
        try:
            print(debug_module + "create directory " + error_count_directory);
            os.umask(000)
            os.makedirs(error_count_directory, 0o777)    # NET edit. (Allow removal of directory on disk)
        except OSError as exception:
            print(debug_module + "WARN: Cannot create directory" + error_count_directory);

    full_error_count_pathname = error_count_directory + error_count_filename;

    try:
        f = open(full_error_count_pathname,'w');
    except IOError:
        print(debug_module + "ERROR: Cannot open file for writing " + full_error_count_pathname);
    else:
        with f:
            f.write(str(i_error_count));
            log_this("INFO",g_routine_name,"FULL_ERROR_COUNT_PATHNAME " + full_error_count_pathname + " NEW_COUNT " + str(i_error_count));
    return;


if __name__ == '__main__':
    full_pathname_to_download = "https://oceandata.sci.gsfc.nasa.gov/cgi/getfile/V2016293000000.L2_SNPP_SST.nc";
    i_filelist_name = os.getenv('OBPG_RUNENV_RESOURCES_HOME','') + "/viirs_filelist.txt.daily_2016_293_date_2016_10_19";
    checksum_value = "b5ea83a4a35268a57ebf6a39fe296a1c06f8278";

    incomplete_filename = handle_downloader_error_historical(full_pathname_to_download,
                                                             i_filelist_name,
                                                             checksum_value);

    print("full_pathname_to_download",full_pathname_to_download);
    print("i_filelist_name",i_filelist_name);
    print("checksum_value",checksum_value);
    print("incomplete_filename",incomplete_filename);
